# This file was *autogenerated* from the file moduleE.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)

def mEp1(x, y):

	sum = _sage_const_0 
	for i in range(len(x)):
		sum += (x[i] - y[i])**_sage_const_2 
	return sqrt(sum).n()

def mEp2(x, y):

	sum = _sage_const_0 
	for i in range(len(x)):
		sum += abs(x[i] - y[i])
	return sum


def mEp3(x, y):

	sum = _sage_const_0 
	for i in range(len(x)):
		if x[i] != y[i]:
			sum += _sage_const_1 
	return sum


def mEp4(x, y):

	if x == y:
		return _sage_const_0 

	m = len(x)
	n = len(y)
	mat = matrix(m, n)

	for i in range(_sage_const_1 , m):
		mat[i, _sage_const_0 ] = i

	for j in range(_sage_const_1 , n):
		mat[_sage_const_0 , j] = j


	for j in range(_sage_const_1 , n):
		for i in range(_sage_const_1 , m):
			
			if x[i] == y[j]:
				mat[i, j] = mat[i-_sage_const_1 , j-_sage_const_1 ]

			else:

				mat[i, j] = min(mat[i-_sage_const_1 , j]+_sage_const_1 , mat[i, j-_sage_const_1 ]+_sage_const_1 , mat[i-_sage_const_1 , j-_sage_const_1 ] +_sage_const_1 )

	ans = mat[m-_sage_const_1 , n-_sage_const_1 ]
	return int(ans)

ans = mEp4(vector([_sage_const_1 ,_sage_const_0 ]), vector([_sage_const_0 ,_sage_const_1 ]))
print type(ans)
print ans

def mEp5(x, y):
	xm = []
	ym = []
	xcur = []
	ycur = []

	for i in range(len(x)):
		xcur.append(x[i])
		ycur.append(y[i])
		if (i + _sage_const_1 ) % sqrt(len(x)) == _sage_const_0 :
			xm.append(xcur)
			ym.append(ycur)
			xcur = []
			ycur = []

	xm = matrix(xm)
	ym = matrix(ym)

	return (xm - ym).rank()



def mEp6(L, dist):

	for p1 in L:
		closest = None
		for p2 in L:
			if p1 is not p2:
				
				if closest is None:
					#assume first point is the closest.
					closest = (p2[_sage_const_0 ], p2[_sage_const_1 ], dist(p1[_sage_const_0 ], p2[_sage_const_0 ]) )
				else:
					if dist(p1[_sage_const_0 ], p2[_sage_const_0 ]) < closest[_sage_const_2 ]:
						closest = ( p2[_sage_const_0 ], p2[_sage_const_1 ], dist(p1[_sage_const_0 ], p2[_sage_const_0 ]) )	
		if p1[_sage_const_1 ] != closest[_sage_const_1 ]:
			return False
	return True


def mEp7(L, J, dist):

	#Store the points after we label them.
	labeled = []
	#For each unlabeled point.
	for q in J:
		#No closest point is known
		closest = None
		#So - for each point that has been labeled
		for p in L:
			#Find the distance
			d = dist(q, p[_sage_const_0 ])
			#If this is the first point we check, we asume he's the closest one.
			if closest is None:
				closest = (p[_sage_const_0 ], p[_sage_const_1 ], d)
			#But if we know a point, we have to check if this point is actually closer.
			else:
				#So - if the distance between this point and the currently assumed closest point is the same
				if d == closest[_sage_const_2 ]:
					#We select the point that has the lower class (closest might have class 4, but p has class 2 - so we select 2)
					closest = closest if (closest[_sage_const_1 ] < p[_sage_const_1 ]) else (p[_sage_const_0 ], p[_sage_const_1 ], d)
				#If we find a point that is actually closer then the point we last said was closest we just replace it
				elif d < closest[_sage_const_2 ]:
					closest = (p[_sage_const_0 ], p[_sage_const_1 ], d)
		#After checking all the points in L we have found the closest point, so we add the previously unclassified point q to our list
		#and add his class as well - and then carry on to the next point in q.
		labeled.append((q, closest[_sage_const_1 ]))

	#all done.
	return labeled


class Node:
	
	def __init__(self, location, c=None):
		self._location = location
		self._luClass = c
		self._neighbours = []

	def __repr__(self):
		return "Node: ({0}), {1}\n".format(self._location, self._luClass)

	def location(self):
		return self._location

	def luClass(self):
		return self._luClass

	def addNeighbour(self, node, dist):
		d = dist(self.location(), node.location())
		self._neighbours.append((node, d))

	def classify(self, k):
		neighbours = sorted(self._neighbours, key=lambda x: x[_sage_const_1 ])
		neighbours = neighbours[:k]

		frequency = {}
		for n in neighbours:
			n = n[_sage_const_0 ]
			#import time; time.sleep(10)
			if n.luClass() in frequency:
				frequency[n.luClass()] += _sage_const_1 
			else:
				frequency[n.luClass()] = _sage_const_1 

		most_frequent = None
		freq = _sage_const_0 
		for f in frequency:
			if most_frequent is None:
				most_frequent = f
				freq = frequency[f]
			else:
				if frequency[f] == freq:
					if f < most_frequent:
						most_frequent = f
						freq = most_frequent[f]
				elif frequency[f] > freq:
					most_frequent = f
					freq = frequency[f]

		self._luClass = most_frequent



def mEp8(L, J, dist, k):

	sortedNodes = []
	unsortedNodes = []

	for p in L:
		node = Node(location=p[_sage_const_0 ], c=p[_sage_const_1 ])
		sortedNodes.append(node)

	for q in J:
		node = Node(location=q)
		unsortedNodes.append(node)

	after_classification = []

	for unsortedNode in unsortedNodes:
		for sortedNode in sortedNodes:
			unsortedNode.addNeighbour(sortedNode, dist)
		unsortedNode.classify(k)
		after_classification.append( (unsortedNode.location(), unsortedNode.luClass()) )

	return after_classification


