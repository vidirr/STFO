# This file was *autogenerated* from the file gameoflife.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)
import copy

class Board:
	
	def __init__(self, initial_layout):

		self._aliveCells = {}
		self._frozenCells = {}
		self._possibleRevival = []

		self._cells = {}

		self._r = initial_layout.nrows()
		self._c = initial_layout.ncols()

		#Construct the original "board"
		for i in xrange(self._r):
			for j in xrange(self._c):

				alive = True if (initial_layout[i, j] ==  _sage_const_1 ) else False
				#All cells are stored in a ditionary that is mapped by their position on the board.
				#self._cells[c.pos()] = c

				#Keep track of the live cells.
				if alive:
					c = Cell(pos=(i, j), alive=alive, board=self)
					self._aliveCells[c.pos()] = c


	def play(self):

		self.findPossibleRevivals()

		cells = self._aliveCells
		for cell in cells:
			cells[cell].update()

	def display(self):
		print " ",
		for i in range(self._c):
			print i,
		print ""

		for i in range(self._c):
			print i,
			for j in range(self._r):
				if (i, j) in self._aliveCells or (i, j) in self._frozenCells:
					print "X",
				else:
					print " ",
			print ""
		print "\n"

	def live(self):
		print self._aliveCells

	def getActiveCells(self):
		return dict( self._aliveCells.items() +  self._frozenCells.items() )


	def nrows(self):
		return self._r

	def ncols(self):
		return self._c

	def findPossibleRevivals(self):
		pass


class Cell:

	def __init__(self, pos, alive, board, neighbours=[]):

		self._pos = pos
		self._alive = alive
		self._neighbours  = neighbours
		self._board = board

	def __repr__(self):
		return str(self._pos) + " - " + str(self._alive)

	def setNeighbours(neighbours):
		self._neighbours = neighbours

	def getNeighbours(self):
		return self._neighbours

	def addNeighbour(cell):
		self._neighbours.append(cell)

	def isAlive(self):
		return self._alive

	def kill(self):
		self._alive = False

	def pos(self):
		return self._pos

	def x(self):
		return self._pos[_sage_const_0 ]

	def y(self):
		return self._pos[_sage_const_1 ]

	def update(self):
		n = self.findNeighbours()

		#If True then survives, False dead.
		if n <= _sage_const_1 :
			return False
		if n >= _sage_const_4 :
			return False
		else:
			return False



	def findNeighbours(self):
		b = self._board
		cells = b.getActiveCells()
		r, c = self.pos()

		rmin = (r - _sage_const_1 ) if (r - _sage_const_1  >= _sage_const_0 ) else _sage_const_0 
		rmax = (r + _sage_const_1 ) if (r + _sage_const_1  < b.nrows()) else b.nrows()
		cmin = (c - _sage_const_1 ) if (c - _sage_const_1  >= _sage_const_0 ) else _sage_const_0 
		cmax = (c + _sage_const_1 ) if (c + _sage_const_1  < b.ncols()) else b.ncols()

		n = _sage_const_0 
		#Count neighbours
		for i in range(rmin, rmax):
			for j in range(cmin, cmax):
				if (i, j) in cells:
					n += _sage_const_1 
		return n





def mDp4(m, k):

	b = Board(m)
	for i in range(k):
		print "Step: ", k + _sage_const_1 
		print ""
		b.display()
		b.play()



m = Matrix([ [_sage_const_1 , _sage_const_0 , _sage_const_0 ], [_sage_const_0 , _sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_0 , _sage_const_1 ] ])
mDp4(m, _sage_const_3 )
